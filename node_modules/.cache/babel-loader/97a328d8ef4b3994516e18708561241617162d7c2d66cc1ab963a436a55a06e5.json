{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        parent: this,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        mask: defs[char],\n        isOptional: optionalBlock\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","constructor","opts","arguments","length","undefined","definitions","Object","assign","DEFAULTS","_update","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","parent","lazy","eager","placeholderChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","value","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","args","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["/Users/home/IT-lessons/react-project/project/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        parent: this,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        mask: defs[char],\n        isOptional: optionalBlock\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}