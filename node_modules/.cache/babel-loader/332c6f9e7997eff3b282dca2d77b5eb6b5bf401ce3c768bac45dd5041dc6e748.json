{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags));\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.dispatch(appended, this, flags);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, masked.currentMaskFlags(flags));\n      const weight = m.rawInputValue.length;\n      return {\n        weight,\n        index\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","normalizePrepare","objectIncludes","ChangeDetails","createMask","Masked","IMask","_excluded","_excluded2","MaskedDynamic","constructor","opts","Object","assign","DEFAULTS","currentMask","_update","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","prevValueBeforeTail","tail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","_this$currentMask","forEach","unmaskedValue","typedValue","String","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","overwrite","console","warn","eager","skipInvalid","maskEquals","every","_mask$mi","oldMask","restOpts","typedValueEquals","_this$currentMask5","masked","inputs","index","weight","sort","i1","i2","default"],"sources":["/Users/home/IT-lessons/react-project/project/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags));\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.dispatch(appended, this, flags);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, masked.currentMaskFlags(flags));\n      const weight = m.rawInputValue.length;\n      return {\n        weight,\n        index\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}